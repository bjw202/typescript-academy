# 🚀 AI 협업 콘텐츠 제작 워크플로우 최적화 보고서 : `flow-recommendation.md`

## 1. 개요 및 목적
본 보고서는 `typescript-academy` 프로젝트 진행 과정을 회고하며, **"기획(Claude) → 구현(Antigravity) → 배포"**로 이어지는 AI 협업 파이프라인의 효율성을 극대화하기 위한 분석 및 제안서입니다.

이번 프로젝트는 매우 성공적이었으나, **Content(교육 내용)**와 **Directive(작업 지시)**가 혼재된 비정형 데이터로 인해 구현 단계에서 수동 정제 작업이 발생했습니다. 이를 구조화/자동화하여 생산성을 10배 이상 높이는 것이 목표입니다.

---

## 2. 오류 분석 및 미스커뮤니케이션 사례 (Retrospective)

이번 작업에서 발생한 주요 마찰(Friction) 지점과 원인을 분석했습니다.

### 2.1 혼합된 컨텍스트 (Mixed Context)
- **현상**: 클로드가 생성한 마크다운 파일 안에 **순수 교육 콘텐츠**, **UI 디자인 지시어**(예: "여기엔 아코디언을 넣어주세요"), **이미지 프롬프트 제안** 등이 텍스트로 섞여 있었습니다.
- **문제**: 안티그래비티(구현 AI)가 이를 코드로 옮길 때, 어떤 것이 사용자에게 보여줄 텍스트이고, 어떤 것이 개발자가 구현해야 할 기능인지 구분하기 위해 문맥을 일일이 해석해야 했습니다.
- **결과**: "UI 지시어 제거 및 정제"라는 전처리 과정에 많은 리소스가 소모됨.

### 2.2 비정형 데이터 포맷 (Unstructured Handoff)
- **현상**: 전체 챕터 내용이 하나의 거대한 마크다운 파일로 전달됨.
- **문제**: 파일 용량이 너무 커서(Context Window 압박), 한 번에 처리하지 못하고 챕터별로 쪼개거나 내용을 요약해서 읽어야 하는 번거로움이 발생.
- **결과**: 작업 누락 가능성 증가 및 컨텍스트 스위칭 비용 발생.

### 2.3 모호한 구현 명세 (Ambiguous Specs)
- **현상**: "나노바나나 이미지를 넣어줘"와 같은 자연어 지시는 있었으나, 구체적인 파일명, 위치, Alt 텍스트 포맷이 정의되지 않음.
- **문제**: 구현 단계에서 즉시 실행하지 못하고, "어디에 넣을까요?", "어떤 프롬프트로 생성할까요?"를 다시 기획해야 함.
- **결과**: 기획-구현 간의 핑퐁(Round-trip) 발생.

---

## 3. 최적화된 워크플로우 제안 (Recommendation Loop)

오류를 원천 차단하고 작업을 자동화하기 위해 **"엄격하게 구조화된 핸드오프(Structured Handoff)"** 프로토콜을 제안합니다.

### 🔄 The "Structured Content" Pipeline

#### STEP 1: 기획 및 콘텐츠 생성 (Claude)
클로드에게 자유로운 작문을 시키되, **결과물 포맷**은 엄격하게 제한합니다.

**✅ 추천 프롬프트 지침:**
> "콘텐츠를 생성할 때, 순수 텍스트(Prose)와 메타데이터(Metadata)를 분리해줘. 각 챕터는 개별 파일로 분리하고, 이미지는 별도 JSON 블록으로 정의해."

**Output Format (예시):**

```markdown
---
title: "Chapter 1: Why TypeScript"
slug: "ch01-why-typescript"
layout: "lesson"
---

## 1.1 Intro
(교육 내용 텍스트...)

<!-- UI-DIRECTIVE: { "component": "Dialogue", "props": { "speakers": ["Junior", "Senior"], "content": "..." } } -->

(교육 내용 텍스트...)

<!-- ASSET-Request: { "type": "image", "prompt": "Nano banana holding shield", "location": "bottom" } -->
```

#### STEP 2: 중간 검증 및 분리 (User / Script)
안티그래비티에게 넘기기 전, 데이터가 포맷에 맞는지 확인합니다.
- UI 지시어(`<!-- UI-DIRECTIVE -->`)가 주석 형태로 명확히 분리되어 있으면, 구현 AI가 이를 파싱하여 컴포넌트로 자동 변환하기 쉽습니다.

#### STEP 3: 구현 및 코딩 (Antigravity)
구조화된 입력을 바탕으로 기계적인 변환 작업을 수행합니다.

1.  **Skeleton Generation**: 폴더 구조 및 빈 MDX 파일 생성.
2.  **Asset Generation (Auto)**: `ASSET-Request` 태그를 파싱하여, 이미지 생성 도구(`generate_image`)를 자동으로 배치 실행.
3.  **Component Wiring**: `UI-DIRECTIVE`를 파싱하여 리액트 컴포넌트(`Dialogue.tsx`) 코드로 변환 및 삽입.

#### STEP 4: 품질 검수 및 배포 (Verification)
- **Lint Check**: 깨진 링크나 잘못된 문법 확인.
- **Visual Check**: 생성된 이미지가 맥락에 맞는지 확인.

---

## 4. 제안하는 포맷 표준 (Protocol)

향후 작업 시 클로드에게 요청할 **"표준 출력 양식"**입니다.

### 4.1 디렉토리 구조 표준
```
project-root/
├── content/
│   ├── manifest.json       # 챕터 순서 및 메타데이터
│   ├── assets/             # 이미지 프롬프트 리스트
│   └── chapters/           # 순수 마크다운 (UI 지시어는 주석 처리)
└── specs/
    ├── ui-components.md    # 필요한 UI 컴포넌트 명세 (아코디언, 퀴즈 등)
    └── design-system.md    # 컬러, 폰트, 캐릭터 설정
```

### 4.2 컴포넌트 호출 표준 (MDX Friendly)
자연어 지시 대신 **Pseudo-Code**나 **XML 태그**를 사용하도록 가이드합니다.

**Bad (자연어):**
> "여기서 주니어 개발자가 질문하는 대화창을 넣어줘."

**Good (명시적 태그):**
```jsx
<Dialogue
  type="question"
  speaker="Junior"
  text="왜 굳이 타입을 써야 하나요?"
/>
```

---

## 5. 기대 효과

이 워크플로우를 도입하면 다음과 같은 변화가 일어납니다.

| 구분 | 현재 (As-Is) | 개선 (To-Be) |
| :--- | :--- | :--- |
| **작업 방식** | 텍스트 읽고 -> 해석하고 -> 코드 작성 | 데이터 파싱 -> 코드 자동 생성 |
| **이미지 작업** | 문맥보고 프롬프트 고민 후 생성 | 프롬프트 리스트 로드 -> 일괄 생성 |
| **오류율** | 텍스트 혼동으로 인한 마크업 에러 높음 | 구조화된 데이터로 에러 0% 수렴 |
| **속도** | 챕터당 30~60분 | 챕터당 3분 (검수 시간 제외) |

**결론**:
AI와의 협업에서 가장 중요한 것은 **"모호함(Ambiguity)의 제거"**입니다.
클로드는 "뛰어난 기획자"로 두고, 안티그래비티는 "민첩한 빌더"로 정의하여, **기획서(Spec)** 자체를 코드로 변환하기 쉬운 형태(JSON/Frontmatter)로 정의하는 것이 성공의 열쇠입니다.
