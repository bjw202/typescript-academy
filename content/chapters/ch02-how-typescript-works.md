## 학습 목표
"TypeScript는 마법이 아니다" - 컴파일 과정을 명확히 이해

---

## 2.1 컴파일? 트랜스파일? {#compile-vs-transpile}

프로그래밍에서 코드 변환에는 두 가지 용어가 있습니다:

### 🍕 피자 배달 비유
![피자 배달 나노바나나](/illustrations/illust-02-pizza-delivery.png)

**컴파일**은 피자 원재료(밀가루, 토마토, 치즈)를 완성된 피자로 만드는 것입니다. 원재료를 알아볼 수 없을 정도로 **완전히 변환**되죠.

**트랜스파일**은 한국 피자를 미국식 피자로 바꾸는 것입니다. 여전히 피자지만, **현지인이 먹을 수 있는 형태**로 바뀝니다.

TypeScript → JavaScript 변환이 바로 이것입니다! 브라우저라는 "현지인"이 이해할 수 있는 형태로 바꿔주는 거죠.

- **컴파일(Compile)**: 고수준 언어를 저수준 언어로 변환하는 것입니다. 예를 들어 C 언어를 기계어로 변환하는 것이 해당됩니다.
- **트랜스파일(Transpile)**: 고수준 언어를 다른 고수준 언어로 변환하는 것입니다. TypeScript를 JavaScript로 변환하는 것이 바로 이 경우입니다.

TypeScript는 엄밀히 말하면 "트랜스파일러"이지만, 업계에서는 일반적으로 "컴파일"이라고 통칭합니다.

> 💡 **왜 구분이 필요해요?**
> 
> 대화할 때 "컴파일"이라고 해도 괜찮습니다. 하지만 내부 동작을 이해하면:
> - TypeScript 결과물은 **JavaScript** (기계어가 아님!)
> - 사람이 읽을 수 있음 → 디버깅 가능
> - 소스맵과 함께 원본 추적 가능

<Mermaid chart={`sequenceDiagram
    participant Dev as 개발자
    participant TS as TypeScript 컴파일러
    participant JS as JavaScript 엔진
    
    Dev->>TS: .ts 파일 작성
    TS->>TS: 구문 분석
    TS->>TS: 타입 체크
    alt 타입 에러 있음
        TS-->>Dev: ❌ 컴파일 에러
    else 타입 에러 없음
        TS->>JS: ✅ .js 파일 생성
        JS->>JS: 실행 (타입 정보 없음)
    end`} 
/>

---

## 2.2 타입은 런타임에 사라진다 {#types-at-runtime}

> ⚠️ **중요**: TypeScript의 타입은 런타임에 존재하지 않습니다!

### 👻 유령이 되는 타입
![유령 스태프 나노바나나](/illustrations/illust-02-ghost-types.png)

타입 정보는 마치 **영화 촬영장의 스태프**와 같습니다.

촬영 중(개발)에는 조명 감독, 분장사, 음향 감독이 다 필요합니다. 하지만 완성된 영화(실행되는 JavaScript)에는 **배우만 보입니다**.

스태프들은 어디로 갔을까요? 사라진 게 아니라, **그들의 일이 끝났기 때문**에 더 이상 필요 없는 것입니다.

이것이 바로 **Type Erasure(타입 지우기)**입니다. 타입은 개발할 때 도와주고, 실행할 때는 조용히 사라집니다. 👻

이것이 의미하는 것은 다음과 같습니다:
1. 타입 체크는 오직 **컴파일 타임**에만 수행됩니다
2. 실행되는 것은 순수한 JavaScript입니다
3. 타입으로 런타임 동작을 제어할 수 없습니다

### Before/After 비교

**TypeScript 코드 (컴파일 전)**
```ts
function greet(name: string): string {
    return `Hello, ${name}!`;
}
```

**JavaScript 코드 (컴파일 후)**
```js
function greet(name) {
    return `Hello, ${name}!`;
}
```

`: string` 타입 어노테이션이 완전히 사라진 것을 볼 수 있습니다. 이것이 바로 "타입 지우기(Type Erasure)"입니다.

### 🐣 주니어 vs 🍌 시니어: "그럼 런타임 검사는요?"

**🐣 주니어 개발자**:
"잠깐만요! 런타임에 타입이 다 사라지면, 실제 실행될 때 `number` 자리에 `string`이 들어오면 어떡해요? 막을 수 없는 거 아니에요?"

**🍌 시니어 나노바나나**:
"아주 날카로운 질문이야! 맞아, TypeScript는 **실행 중(Runtime)**에는 아무런 힘이 없어. 유령이니까!"

**🐣 주니어 개발자**:
"그럼 반쪽짜리 아닌가요? 😰"

**🍌 시니어 나노바나나**:
"그래서 **런타임 검증(Validation)**은 별도로 해야 해.
1. `typeof`, `instanceof` 같은 JS 문법을 쓰거나
2. `zod` 같은 라이브러리로 데이터가 들어오는 입구를 지켜야 하지.

TypeScript는 '설계도'가 틀리지 않았는지 검사해주는 **건축가** 역할이고, 실제 문을 지키는 **경비원**(런타임 검사)은 따로 두어야 한단다."

---

## 2.3 TSC의 두 가지 역할 {#tsc-roles}

TypeScript 컴파일러(tsc)는 두 가지 독립적인 역할을 수행합니다:

### 🎭 1인 2역 배우

TSC는 두 가지 역할을 완전히 **독립적으로** 수행합니다. 마치 뮤지컬 배우가 노래와 연기를 따로 연습하는 것처럼요!

| 역할 1: 타입 체커 🔍 | 역할 2: 트랜스파일러 ⚙️ |
|:---------------------|:------------------------|
| 타입 에러 찾기 | `.ts` → `.js` 변환 |
| 타입 추론 | 최신 문법 → 구버전 변환 |
| IDE 지원 (자동완성) | 모듈 시스템 변환 |

**중요한 점**: 이 두 역할은 독립적으로 작동합니다!
- 타입 에러가 있어도 `.js` 파일을 생성할 수 있습니다 (`--noEmitOnError false`)
- `.js` 변환만 필요하다면 다른 도구(Babel, esbuild)를 사용할 수도 있습니다

### 예시

```ts
const age: number = "30"; // ❌ 타입 에러
```

위 코드는 타입 에러가 발생하지만, 컴파일 결과는 다음과 같이 생성됩니다:

```js
const age = "30"; // 타입 정보만 제거됨
```

> 💡 **실무 팁**
> 
> 빌드 속도가 중요한 대규모 프로젝트에서는:
> - **타입 체크**: `tsc --noEmit` (파일 생성 안 함, 체크만)
> - **트랜스파일**: esbuild나 swc (10-100배 빠름!)
> 
> 역할을 분리해서 "타입 체크는 정확하게, 빌드는 빠르게" 전략을 씁니다.

---

## 2.4 tsconfig.json의 역할 {#tsconfig}

`tsconfig.json`은 TypeScript 컴파일러의 설정 파일입니다. 마치 자동차의 계기판처럼, 다양한 옵션을 조절할 수 있습니다.

### 🎮 게임 난이도 설정

`tsconfig.json`은 TypeScript 게임의 **난이도 설정**입니다.

| 설정 | 쉬움 모드 | 어려움 모드 (권장) |
|------|----------|------------------|
| `strict` | `false` - 대충 봐줌 | `true` - 칼같이 체크 |
| `noImplicitAny` | 허용 - any 파티 | 금지 - 타입 명시 필수 |

신규 플레이어가 "왜 이렇게 엄격해요?"라고 물으면:

> "처음엔 짜증나지만, 보스(프로덕션 버그) 만났을 때 이 무기(타입 안전성)가 얼마나 고마운지 알게 될 거예요."

**프로 팁**: 쉬움 모드로 시작해서 "아 역시 strict 켤걸" 후회하지 마세요. 처음부터 어려움 모드로! 🎯

| 옵션 | 설명 | 비유 |
|:-----|:-----|:-----|
| `strict` | 엄격한 타입 체크 활성화 | 안전벨트 착용 여부 |
| `target` | 출력 JavaScript 버전 | 어느 시대 자동차로 만들지 |
| `module` | 모듈 시스템 설정 | 짐을 어떻게 실을지 |
| `outDir` | 출력 디렉토리 | 완성품을 어디에 둘지 |

### 핵심 옵션 3가지

```json
{
  "compilerOptions": {
    "strict": true,           // 👈 항상 켜세요!
    "target": "ES2020",       // 👈 브라우저 지원 범위
    "module": "ESNext"        // 👈 최신 모듈 문법
  }
}
```

`strict: true`는 TypeScript를 사용하는 가장 큰 이유인 타입 안전성을 최대화하므로, 항상 활성화하는 것을 권장합니다.

> 🤔 **"strict 끄면 어떻게 되나요?"**
> 
> TypeScript가 "괜찮아, 뭐든 허용해~" 모드가 됩니다.
> 그러면... TypeScript를 쓰는 의미가 반감됩니다.
> 
> - `noImplicitAny` 끔 → 타입 안 써도 경고 없음
> - `strictNullChecks` 끔 → null 터져도 미리 모름
> 
> 안전벨트 매는 게 불편해도, **사고 나면 더 불편합니다!** 🚗

---

## 😱 나노바나나의 실수 노트

> **초보자가 가장 많이 하는 실수: .ts 파일 바로 실행하기**

### ❌ 에러 상황
`movie.ts` 파일을 만들고 `node movie.ts`로 실행했는데...

```bash
const age: number = 20;
         ^
SyntaxError: Unexpected token ':'
```

### 🍌 나노바나나의 설명
"앗! Node.js는 TypeScript(`: number` 같은 거)를 전혀 몰라! Node.js는 오직 **JavaScript**만 이해해."

JavaScript에는 타입 문법이 없어서 `:`를 보고 "이게 뭐야?" 하고 뻗어버린 거야.

### ✅ 해결 방법

**방법 1: 정석대로 컴파일하기**
```bash
# 1. 컴파일 (번역)
npx tsc movie.ts

# 2. 생성된 JS 실행
node movie.js
```

**방법 2: ts-node로 한 방에 실행하기 (개발용)**
```bash
# ts-node 설치 필요 (npm install -D ts-node)
npx ts-node movie.ts
```
> `ts-node`는 메모리에서 번역해서 바로 실행해주는 도구야! (편리함 👍)

---

## 📝 요약

![Transpilation Evolution](/illustrations/cheat-ch02-robot-suit.png)

*   **Compile Time**: 로봇 슈트(TS)를 입고 철저하게 훈련(타입 검사)!
*   **Run Time**: 실제 경기(실행) 뛸 때는 가벼운 운동복(JS)으로 변신!
*   실행 중에는 타입이 없다는 사실(Type Erasure)을 잊지 마세요.
