## 학습 목표
"왜 TypeScript가 필요한지" 명확히 이해하고, JavaScript의 한계를 체감하게 만들기

---

## 1.1 JavaScript의 자유와 혼돈 {#js-freedom}

JavaScript는 매우 자유로운 언어입니다. 변수에 어떤 타입의 값이든 넣을 수 있고, 함수에 어떤 인자든 전달할 수 있습니다. 하지만 이 자유에는 **대가**가 따릅니다. 너무 자유로워서 오히려 위험할 수 있다는 것이죠.

### 🎉 규칙 없는 파티

JavaScript 세계는 **규칙 없는 파티**와 같습니다.

처음엔 자유롭고 신나죠! 아무 음료나 섞어 마시고, 아무 데나 앉고, 아무렇게나 행동해도 됩니다.

```js
let 음료 = "콜라";
음료 = 42;           // 숫자로 바꿔도 OK
음료 = [1, 2, 3];    // 배열로 바꿔도 OK
음료 = { ice: true }; // 객체로 바꿔도 OK (대체 이게 무슨 음료야?!)
```

하지만 파티가 끝나면? **정리할 때 지옥**입니다.
"이게 뭐였지?", "누가 이래놓은 거야?", "어디서부터 잘못된 거지?"

프로덕션에서 버그를 발견하면 그 기분이 바로 이겁니다. 😱

### 실제 버그 사례
- **Stripe**: 사소한 타입 에러로 인해 사용자 과금 오류가 발생한 적이 있습니다.
- **Airbnb**: TypeScript 도입 후 버그가 38% 감소했다고 보고했습니다.
- **Slack**: 전체 코드베이스를 TypeScript로 전환하여 안정성을 크게 높였습니다.

> 💡 **TypeScript는 파티에 규칙을 세우는 것**입니다.
> "콜라잔에는 콜라만!", "맥주잔에는 맥주만!"
> 처음엔 불편하지만, 뒷정리(디버깅)가 훨씬 쉬워집니다.

![자유로운 바나나의 여정](/illustrations/illust-01-free-banana-journey.png)

위 그림처럼 JavaScript 세상에서는 바나나가 자유롭게 날아다니지만, 런타임 에러라는 화산(Volcano)을 만나면 예기치 않게 프로그램이 중단될 수 있습니다. 개발자는 이 폭발(Crash)을 뒤늦게 발견하고 당황하게 됩니다.

### 직접 체험해보기

아래 코드에서 `add` 함수는 수학적 덧셈을 의도했지만, 문자열 `"2"`가 전달되자 JavaScript는 조용히 문자열 연결(`"12"`)을 수행합니다. 이것이 바로 **침묵하는 버그**입니다.

<CodePlayground 
  initialCode={`// JavaScript의 위험성: 타입 체크가 없습니다.
function add(a, b) {
  return a + b;
}

// 의도: 1 + 2 = 3
// 실제: 1 + "2" = "12"
console.log(add(1, "2"));`}
  language="javascript"
/>

> 🔥 **침묵하는 버그가 무서운 이유**
> 
> 에러가 나면 그나마 다행입니다. **에러도 안 나고 이상하게 동작하는 버그**가 진짜 무섭습니다.
> 
> - 장바구니 금액이 이상하게 계산됨 → 고객 클레임
> - 날짜가 이상하게 저장됨 → 리포트 전체 오류
> - 권한 체크가 이상하게 동작함 → 보안 사고 😰

---

## 1.2 타입 에러의 비용 {#cost-of-type-errors}

버그를 언제 발견하느냐에 따라 수정 비용은 천차만별입니다. 코드를 작성할 때 바로 발견하면 **1달러**가 들지만, 사용자가 발견하면 **10,000달러**의 손실이 발생할 수 있습니다.

### 🏥 병원 비유: 예방 vs 응급실

건강 검진(TypeScript)은 귀찮고 시간이 걸립니다. 하지만 응급실(런타임 에러)은 훨씬 비쌉니다.

TypeScript를 쓰는 것은 마치 **코드에게 건강 검진**을 시키는 것입니다:
- "아, 여기 콜레스테롤(any 타입)이 좀 높네요"
- "이 혈압(undefined)은 관리가 필요해요"

미리 발견하면 생활습관(코드) 개선으로 해결됩니다.
나중에 발견하면? 수술(핫픽스) + 입원(야근) 🏥💸

### 비용 비교
- **작성 시 (TypeScript)**: 즉시 수정 (비용: $1) ← 💚 최고!
- **컴파일 시 (TypeScript)**: 실행 전 발견 (비용: $10)
- **테스트 시 (JavaScript)**: 테스트 실행 필요 (비용: $100)
- **프로덕션 (JavaScript)**: 사용자 불만, 긴급 패치 (비용: $10,000 😱)

TypeScript는 에러 발견 시점을 **프로덕션**에서 **개발 단계**로 앞당겨줍니다. 이것을 시각화하면 다음과 같습니다.

<Mermaid chart={`graph TD
    A["코드 작성"] --> B{"타입 체크"}
    B -->|TypeScript| C["컴파일 에러 🚨"]
    B -->|JavaScript| D["테스트 단계"]
    C --> E["작성 중 즉시 수정 ($1)"]
    D --> F{"테스트 통과?"}
    F -->|실패| G["디버깅 수정 ($100)"]
    F -->|통과하지만 버그 존재| H["프로덕션 배포"]
    H --> I["사용자 에러 발견 ($10,000 💸)"]
    
    style C fill:#fecaca,stroke:#ef4444
    style E fill:#bbf7d0,stroke:#22c55e
    style I fill:#fecaca,stroke:#ef4444,stroke-width:4px`} 
/>

> 💡 **핵심 포인트**
> 
> 에러는 **언젠가는** 발견됩니다. 문제는 **언제** 발견하느냐입니다.
> 
> - 내가 발견? 커피 한 잔의 시간 ☕
> - 동료가 발견? PR 리뷰 코멘트와 민망함 😅
> - 사용자가 발견? 핫픽스, 야근, 그리고 트라우마 😭

---

## 1.3 TypeScript가 해결하는 것들 {#what-ts-solves}

TypeScript는 JavaScript 위에 '타입'이라는 안전장치를 씌운 것입니다. 마치 **보디가드**와 같습니다.

### 🛡️ 보디가드가 하는 일

"사장님, 저 사람 수상해요. 못 들어오게 막았습니다."

TypeScript 보디가드는 **코드 실행 전에** 수상한 것들을 막아줍니다:
- 🚫 "저 변수, 타입이 안 맞아요"
- 🚫 "저 함수, 인자 개수가 틀려요"
- 🚫 "저 객체, 없는 속성에 접근하려 해요"

| 문제 상황 | JavaScript | TypeScript |
|---|---|---|
| **오타 발생** | 실행 시 런타임 에러 (`undefined is not a function`) | **작성 중** 빨간 밑줄로 경고 |
| **잘못된 타입** | 함수가 엉뚱한 값을 받아 처리함 | **컴파일 에러**로 사전에 차단 |
| **API 변경** | 변경된 필드를 참조하다가 크래시 | 타입 정의만 수정하면 **모든 사용처**에서 에러 표시 |
| **리팩토링** | 어디서 깨질지 몰라 두려움 | **자신감** 있게 수정 가능 |

> 🎯 **실제 체감 효과**
> 
> - IDE 자동완성이 **엄청 좋아짐** (더 이상 API 문서 왔다갔다 안 해도 됨!)
> - 함수 시그니처만 봐도 **뭘 넣고 뭘 받는지** 바로 파악
> - 3개월 전에 짠 코드도 **타입만 보면 이해됨**

---

## 1.4 언제 TypeScript를 써야 할까? {#when-to-use}

모든 프로젝트에 TypeScript가 정답은 아닙니다. 상황에 맞춰 선택하세요.

<Mermaid chart={`flowchart TD
    Start[새 프로젝트 시작] --> Team{팀 규모는?}
    Team -->|1-2명| Term{기간은?}
    Team -->|3명 이상| TS[TypeScript 강력 추천 ✅]
    Term -->|1주 이하| JS[JavaScript도 OK 👌]
    Term -->|1주 이상| TS
    
    style TS fill:#dbeafe,stroke:#3b82f6
    style JS fill:#fef9c3,stroke:#eab308`}
/>

### 💡 실무 조언 (Pro Tip)

**TypeScript를 피해도 되는 경우:**
- 🏃 아주 간단한 프로토타입 (1-2일 내 폐기 예정)
- 📚 학습 곡선이 부담스러운 완전 초보자 팀 (JS 먼저 익히기)
- 🏚️ 빌드 도구 설정이 불가능한 레거시 환경

**TypeScript를 강력 추천하는 경우:**
1. **협업**: 3명 이상의 팀 프로젝트 → 타입이 **문서화 역할**
2. **유지보수**: 3개월 이상 운영될 서비스 → 미래의 내가 고마워함
3. **안정성**: 결제, 데이터 처리 등 중요한 로직 → 버그가 곧 **돈 손실**
4. **라이브러리**: 다른 사람들이 쓸 패키지 개발 → 타입 정의가 **UX**

### 🐣 주니어 vs 🍌 시니어: "꼭 써야 해요?"

**🐣 주니어 개발자**:
"선배님, 저 혼자 개발하는데 굳이 TypeScript 써야 하나요? 설정만 복잡하고 코드만 길어지잖아요."

**🍌 시니어 나노바나나**:
"지금 당장은 그렇게 느낄 수 있어. 하지만 **3개월 뒤의 너**는 다른 사람이라는 걸 기억해."

**🐣 주니어 개발자**:
"네? 제가 다른 사람이라뇨?"

**🍌 시니어 나노바나나**:
"3개월 뒤에 이 코드를 다시 보면 '이 함수에 뭘 넣어야 하지?' 하고 헤매게 될 거야. TypeScript는 **미래의 너에게 남기는 편지**(문서)와 같아. 지금 10분 더 쓰는 게 나중에 10시간을 아껴줄 거야!"

### 🚀 시작하기 망설여진다면

"타입 적는 게 귀찮을 것 같아요" → 실제로는 **자동완성 덕분에 더 빨라집니다**

"배우는 데 시간이 오래 걸릴 것 같아요" → **기본 타입만 써도 90%의 효과**를 얻습니다

"기존 JS 프로젝트에 도입하기 어려울 것 같아요" → **점진적 도입**이 가능합니다 (`.js`와 `.ts` 공존 가능!)

TypeScript는 **올인이 아닌 그라데이션**입니다. 조금씩 도입해보세요! 🌈

---

## 😱 나노바나나의 실수 노트

> **초보자가 가장 많이 하는 실수: 설치 확인 안 하기!**

### ❌ 에러 상황
터미널에 `tsc`를 입력했는데 이런 에러가 떠요:

```bash
zsh: command not found: tsc
```

### 🍌 나노바나나의 설명
"어? TypeScript 컴파일러(tsc)가 설치되지 않았거나, 컴퓨터가 tsc가 어디 있는지 모르는 거야!"

TypeScript는 브라우저나 Node.js에 기본으로 들어있지 않아서, **꼭 따로 설치**를 해줘야 해.

### ✅ 해결 방법

**방법 1: 프로젝트 내부에 설치하고 사용하기 (권장)**
```bash
npm install typescript --save-dev
npx tsc --version
```
> `npx`는 "설치된 도구를 실행해줘!"라는 명령어예요.

**방법 2: 내 컴퓨터 전체에 설치하기**
```bash
npm install -g typescript
```
이제 터미널을 껐다 켜면 `tsc` 명령어가 될 거야!

---

## 📝 요약

![TypeScript Shield](/illustrations/cheat-ch01-shield.png)

*   **TypeScript**는 코드의 버그를 막아주는 튼튼한 **방패**입니다.
*   조금 귀찮더라도, 이 방패가 미래의 당신을 지켜줄 거예요!
